use log::debug;
use parking_lot::RwLock;
use rolldown_common::Output;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct ChunkAsset {
    pub content: String,
    pub content_type: String,
}

#[derive(Debug, Clone)]
pub struct MainAsset {
    pub filename: String,
    pub content: String,
    pub content_type: String,
}

/// Manages chunk storage and retrieval
pub struct ChunkManager {
    /// Cache for storing chunk dependencies (filename -> content)
    chunks: Arc<RwLock<HashMap<String, ChunkAsset>>>,
}

impl ChunkManager {
    pub fn new() -> Self {
        Self {
            chunks: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn store_chunks(&self, chunks: HashMap<String, ChunkAsset>) {
        if chunks.is_empty() {
            return;
        }

        let mut chunk_cache = self.chunks.write();
        let count = chunks.len();
        chunk_cache.extend(chunks);
        debug!(
            "Stored {} chunk(s) in cache (total: {})",
            count,
            chunk_cache.len()
        );
    }

    pub fn get_chunk(&self, name: &str) -> Option<ChunkAsset> {
        let chunks = self.chunks.read();

        let candidates = [
            Some(name),
            name.strip_prefix('/'),
            name.strip_prefix("__chunks/"),
            name.strip_prefix("/_chunks/"),
            name.strip_prefix("/__chunks/"),
        ];

        for candidate in candidates.into_iter().flatten() {
            if let Some(chunk) = chunks.get(candidate) {
                return Some(chunk.clone());
            }
        }

        None
    }

    #[allow(dead_code)]
    pub fn list_chunks(&self) -> Vec<String> {
        self.chunks.read().keys().cloned().collect()
    }

    pub fn clear(&self) {
        self.chunks.write().clear();
        debug!("Cleared chunk cache");
    }

    #[allow(dead_code)]
    pub fn chunk_count(&self) -> usize {
        self.chunks.read().len()
    }

    #[allow(dead_code)]
    pub fn has_chunk(&self, name: &str) -> bool {
        let chunks = self.chunks.read();
        let candidates = [
            Some(name),
            name.strip_prefix('/'),
            name.strip_prefix("__chunks/"),
            name.strip_prefix("/_chunks/"),
            name.strip_prefix("/__chunks/"),
        ];

        candidates
            .into_iter()
            .flatten()
            .any(|candidate| chunks.contains_key(candidate))
    }
}

impl Default for ChunkManager {
    fn default() -> Self {
        Self::new()
    }
}

pub struct ChunkProcessor;

impl ChunkProcessor {
    pub fn process_assets(
        assets: &[Output],
        source_path: &PathBuf,
    ) -> Result<(MainAsset, HashMap<String, ChunkAsset>), String> {
        let mut main_output: Option<MainAsset> = None;
        let mut chunks = HashMap::new();

        for asset in assets {
            let content = String::from_utf8(asset.content_as_bytes().to_vec())
                .map_err(|e| format!("Failed to convert asset to UTF-8: {}", e))?;
            let filename = asset.filename();
            let content_type = guess_content_type(filename);

            debug!("Processing asset: {}", filename);

            if Self::is_main_output(filename, source_path) {
                debug!("Identified main output: {}", filename);
                main_output = Some(MainAsset {
                    filename: filename.to_string(),
                    content,
                    content_type: content_type.to_string(),
                });
            } else {
                debug!("Storing as chunk: {}", filename);
                chunks.insert(
                    filename.to_string(),
                    ChunkAsset {
                        content,
                        content_type: content_type.to_string(),
                    },
                );
            }
        }

        if main_output.is_none() {
            main_output = Self::find_fallback_output(assets)?;
        }

        match main_output {
            Some(output) => Ok((output, chunks)),
            None => Err("No JavaScript output generated by rolldown".to_string()),
        }
    }

    fn is_main_output(filename: &str, source_path: &PathBuf) -> bool {
        if !filename.ends_with(".js") {
            return false;
        }

        if let Some(file_stem) = source_path.file_stem() {
            let stem_str = file_stem.to_string_lossy();
            return filename.contains(&stem_str.to_string());
        }

        false
    }

    fn find_fallback_output(assets: &[Output]) -> Result<Option<MainAsset>, String> {
        for asset in assets {
            let filename = asset.filename();
            if filename.ends_with(".js") {
                debug!("Fallback: using first JS asset: {}", filename);
                let content = String::from_utf8(asset.content_as_bytes().to_vec())
                    .map_err(|e| format!("Failed to convert fallback asset to UTF-8: {}", e))?;
                return Ok(Some(MainAsset {
                    filename: filename.to_string(),
                    content,
                    content_type: guess_content_type(filename).to_string(),
                }));
            }
        }
        Ok(None)
    }
}

fn guess_content_type(filename: &str) -> &'static str {
    match Path::new(filename)
        .extension()
        .and_then(|s| s.to_str())
        .map(|s| s.to_ascii_lowercase())
        .as_deref()
    {
        Some("js") | Some("mjs") | Some("cjs") | Some("jsx") | Some("ts") | Some("tsx") => {
            "application/javascript"
        }
        Some("css") => "text/css",
        Some("html") => "text/html",
        Some("json") => "application/json",
        _ => "application/octet-stream",
    }
}
