use log::debug;
use parking_lot::RwLock;
use rolldown_common::Output;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

/// Manages chunk storage and retrieval
pub struct ChunkManager {
    /// Cache for storing chunk dependencies (filename -> content)
    chunks: Arc<RwLock<HashMap<String, String>>>,
}

impl ChunkManager {
    pub fn new() -> Self {
        Self {
            chunks: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn store_chunks(&self, chunks: HashMap<String, String>) {
        if chunks.is_empty() {
            return;
        }

        let mut chunk_cache = self.chunks.write();
        let count = chunks.len();
        chunk_cache.extend(chunks);
        debug!(
            "Stored {} chunk(s) in cache (total: {})",
            count,
            chunk_cache.len()
        );
    }

    pub fn get_chunk(&self, name: &str) -> Option<String> {
        self.chunks.read().get(name).cloned()
    }

    pub fn list_chunks(&self) -> Vec<String> {
        self.chunks.read().keys().cloned().collect()
    }

    pub fn clear(&self) {
        self.chunks.write().clear();
        debug!("Cleared chunk cache");
    }

    pub fn chunk_count(&self) -> usize {
        self.chunks.read().len()
    }

    pub fn has_chunk(&self, name: &str) -> bool {
        self.chunks.read().contains_key(name)
    }
}

impl Default for ChunkManager {
    fn default() -> Self {
        Self::new()
    }
}

pub struct ChunkProcessor;

impl ChunkProcessor {
    pub fn process_assets(
        assets: &Vec<Output>,
        source_path: &PathBuf,
    ) -> Result<(String, HashMap<String, String>), String> {
        let mut main_output = None;
        let mut chunks = HashMap::new();

        for asset in assets {
            let content = String::from_utf8(asset.content_as_bytes().to_vec())
                .map_err(|e| format!("Failed to convert asset to UTF-8: {}", e))?;
            let filename = asset.filename();

            debug!("Processing asset: {}", filename);

            if Self::is_main_output(filename, source_path) {
                debug!("Identified main output: {}", filename);
                main_output = Some(content);
            } else {
                debug!("Storing as chunk: {}", filename);
                chunks.insert(filename.to_string(), content);
            }
        }

        if main_output.is_none() {
            main_output = Self::find_fallback_output(assets)?;
        }

        match main_output {
            Some(output) => Ok((output, chunks)),
            None => Err("No JavaScript output generated by rolldown".to_string()),
        }
    }

    fn is_main_output(filename: &str, source_path: &PathBuf) -> bool {
        if !filename.ends_with(".js") {
            return false;
        }

        if let Some(file_stem) = source_path.file_stem() {
            let stem_str = file_stem.to_string_lossy();
            return filename.contains(&stem_str.to_string());
        }

        false
    }

    fn find_fallback_output(assets: &[Output]) -> Result<Option<String>, String> {
        for asset in assets {
            let filename = asset.filename();
            if filename.ends_with(".js") {
                debug!("Fallback: using first JS asset: {}", filename);
                let content = String::from_utf8(asset.content_as_bytes().to_vec())
                    .map_err(|e| format!("Failed to convert fallback asset to UTF-8: {}", e))?;
                return Ok(Some(content));
            }
        }
        Ok(None)
    }
}
